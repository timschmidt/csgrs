#![doc = " PLY file format support"]
#![doc = ""]
#![doc = " This module provides export functionality for Stanford PLY files,"]
#![doc = " a popular format for 3D scanning, research, and mesh processing applications."]

use crate::float_types::{Real, tolerance};
use crate::triangulated::Triangulated3D;
use crate::vertex::Vertex;
use nalgebra::{Point3, Vector3};
use std::fmt::Debug;
use std::io::Write;

/// Add a vertex to the list, reusing an existing one if position and normal
/// are within `tolerance()`.
fn add_unique_vertex_ply(
    vertices: &mut Vec<Vertex>,
    position: Point3<Real>,
    normal: Vector3<Real>,
) -> usize {
    for (i, existing) in vertices.iter().enumerate() {
        if (existing.position.coords - position.coords).norm() < tolerance()
            && (existing.normal - normal).norm() < tolerance()
        {
            return i;
        }
    }
    vertices.push(Vertex { position, normal });
    vertices.len() - 1
}

fn build_ply_buffers<T: Triangulated3D>(shape: &T) -> (Vec<Vertex>, Vec<[usize; 3]>) {
    let mut vertices = Vec::<Vertex>::new();
    let mut faces = Vec::<[usize; 3]>::new();

    shape.visit_triangles(|tri| {
        let i0 = add_unique_vertex_ply(&mut vertices, tri[0].position, tri[0].normal);
        let i1 = add_unique_vertex_ply(&mut vertices, tri[1].position, tri[1].normal);
        let i2 = add_unique_vertex_ply(&mut vertices, tri[2].position, tri[2].normal);
        faces.push([i0, i1, i2]);
    });

    (vertices, faces)
}

#[doc = " Export any `Triangulated3D` shape to PLY format as a string"]
#[doc = ""]
#[doc = " Creates a Stanford PLY file containing all triangles from `shape`."]
#[doc = ""]
#[doc = " # Arguments"]
#[doc = " * `comment` - Optional comment to include in PLY header"]
pub fn to_ply<T: Triangulated3D>(shape: &T, comment: &str) -> String {
    let (vertices, faces) = build_ply_buffers(shape);

    let mut ply_content = String::new();
    ply_content.push_str("ply\n");
    ply_content.push_str("format ascii 1.0\n");
    ply_content.push_str(&format!("comment {comment}\n"));
    ply_content.push_str("comment Generated by csgrs library\n");
    ply_content.push_str(&format!("element vertex {}\n", vertices.len()));
    ply_content.push_str("property float x\n");
    ply_content.push_str("property float y\n");
    ply_content.push_str("property float z\n");
    ply_content.push_str("property float nx\n");
    ply_content.push_str("property float ny\n");
    ply_content.push_str("property float nz\n");
    ply_content.push_str(&format!("element face {}\n", faces.len()));
    ply_content.push_str("property list uchar int vertex_indices\n");
    ply_content.push_str("end_header\n");

    for vertex in &vertices {
        ply_content.push_str(&format!(
            "{:.6} {:.6} {:.6} {:.6} {:.6} {:.6}\n",
            vertex.position.x,
            vertex.position.y,
            vertex.position.z,
            vertex.normal.x,
            vertex.normal.y,
            vertex.normal.z
        ));
    }

    for face in &faces {
        ply_content.push_str(&format!("3 {} {} {}\n", face[0], face[1], face[2]));
    }

    ply_content
}

#[doc = " Export any `Triangulated3D` shape to a PLY file"]
#[doc = ""]
#[doc = " # Arguments"]
#[doc = " * `writer` - Where to write the PLY data"]
#[doc = " * `comment` - Comment to include in PLY header"]
pub fn write_ply<T: Triangulated3D, W: Write>(
    shape: &T,
    writer: &mut W,
    comment: &str,
) -> std::io::Result<()> {
    let ply_content = to_ply(shape, comment);
    writer.write_all(ply_content.as_bytes())
}

impl<S: Clone + Debug + Send + Sync> crate::mesh::Mesh<S> {
    #[doc = " Export this Mesh to PLY format as a string"]
    pub fn to_ply(&self, comment: &str) -> String {
        self::to_ply(self, comment)
    }

    #[doc = " Export this Mesh to a PLY file"]
    pub fn write_ply<W: Write>(&self, writer: &mut W, comment: &str) -> std::io::Result<()> {
        self::write_ply(self, writer, comment)
    }
}

impl<S: Clone + Debug + Send + Sync> crate::sketch::Sketch<S> {
    #[doc = " Export this Sketch to PLY format as a string"]
    pub fn to_ply(&self, comment: &str) -> String {
        self::to_ply(self, comment)
    }

    #[doc = " Export this Sketch to a PLY file"]
    pub fn write_ply<W: Write>(&self, writer: &mut W, comment: &str) -> std::io::Result<()> {
        self::write_ply(self, writer, comment)
    }
}

impl<S: Clone + Debug + Send + Sync> crate::bmesh::BMesh<S> {
    #[doc = " Export this BMesh to PLY format as a string"]
    pub fn to_ply(&self, comment: &str) -> String {
        self::to_ply(self, comment)
    }

    #[doc = " Export this BMesh to a PLY file"]
    pub fn write_ply<W: Write>(&self, writer: &mut W, comment: &str) -> std::io::Result<()> {
        self::write_ply(self, writer, comment)
    }
}
