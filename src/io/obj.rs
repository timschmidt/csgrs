#![doc = " OBJ file format support"]
#![doc = ""]
#![doc = " This module provides import and export functionality for Wavefront OBJ files,"] 
#![doc = " a widely-supported 3D file format used by many modeling and rendering applications."]

use crate::float_types::{Real, tolerance};
use crate::mesh::Mesh;
use crate::mesh::polygon::Polygon;
use crate::triangulated::Triangulated3D;
use crate::vertex::Vertex;
use crate::sketch::Sketch;
use nalgebra::{Point3, Vector3};
use std::fmt::Debug;
use std::io::{BufRead, Write};

fn add_unique_vertex(vertices: &mut Vec<Point3<Real>>, vertex: Point3<Real>) -> usize {
    for (i, existing) in vertices.iter().enumerate() {
        if (existing.coords - vertex.coords).norm() < tolerance() {
            return i;
        }
    }
    vertices.push(vertex);
    vertices.len() - 1
}

fn add_unique_normal(normals: &mut Vec<Vector3<Real>>, normal: Vector3<Real>) -> usize {
    for (i, existing) in normals.iter().enumerate() {
        if (*existing - normal).norm() < tolerance() {
            return i;
        }
    }
    normals.push(normal);
    normals.len() - 1
}

fn build_obj_buffers<T: Triangulated3D>(
    shape: &T,
) -> (Vec<Point3<Real>>, Vec<Vector3<Real>>, Vec<Vec<(usize, usize)>>) {
    let mut vertices = Vec::<Point3<Real>>::new();
    let mut normals = Vec::<Vector3<Real>>::new();
    let mut faces = Vec::<Vec<(usize, usize)>>::new();

    shape.visit_triangles(|tri| {
        let mut face = Vec::with_capacity(3);
        for v in tri {
            let v_idx = add_unique_vertex(&mut vertices, v.position);
            let n_idx = add_unique_normal(&mut normals, v.normal);
            face.push((v_idx, n_idx));
        }
        if face.len() == 3 {
            faces.push(face);
        }
    });

    (vertices, normals, faces)
}

#[doc = " Export any `Triangulated3D` shape to OBJ format as a string"]
#[doc = ""]
#[doc = " Creates a Wavefront OBJ file containing all triangles from `shape`."]
#[doc = ""]
#[doc = " # Arguments"]
#[doc = " * `object_name` - Name for the object in the OBJ file"]
pub fn to_obj<T: Triangulated3D>(shape: &T, object_name: &str) -> String {
    let (vertices, normals, faces) = build_obj_buffers(shape);

    let mut obj_content = String::new();
    obj_content.push_str("# Generated by csgrs library\n");
    obj_content.push_str(&format!("# Object: {object_name}\n"));
    obj_content.push_str("# https://github.com/timschmidt/csgrs\n\n");
    obj_content.push_str(&format!("o {object_name}\n\n"));

    for vertex in &vertices {
        obj_content.push_str(&format!(
            "v {:.6} {:.6} {:.6}\n",
            vertex.x, vertex.y, vertex.z
        ));
    }
    obj_content.push('\n');

    for normal in &normals {
        obj_content.push_str(&format!(
            "vn {:.6} {:.6} {:.6}\n",
            normal.x, normal.y, normal.z
        ));
    }
    obj_content.push('\n');

    for face in &faces {
        #[allow(clippy::single_char_add_str)]
        obj_content.push_str("f");
        for (vertex_idx, normal_idx) in face {
            obj_content.push_str(&format!(" {}//{}", vertex_idx + 1, normal_idx + 1));
        }
        obj_content.push('\n');
    }

    obj_content
}

#[doc = " Export any `Triangulated3D` shape to an OBJ file"]
#[doc = ""]
#[doc = " # Arguments"]
#[doc = " * `writer` - Where to write the OBJ data"]
#[doc = " * `object_name` - Name for the object in the OBJ file"]
pub fn write_obj<T: Triangulated3D, W: Write>(
    shape: &T,
    writer: &mut W,
    object_name: &str,
) -> std::io::Result<()> {
    let obj_content = to_obj(shape, object_name);
    writer.write_all(obj_content.as_bytes())
}

impl<S: Clone + Debug + Send + Sync> Mesh<S> {
    #[doc = " Export this Mesh to OBJ format as a string"]
    pub fn to_obj(&self, object_name: &str) -> String {
        self::to_obj(self, object_name)
    }

    #[doc = " Export this Mesh to an OBJ file"]
    pub fn write_obj<W: Write>(
        &self,
        writer: &mut W,
        object_name: &str,
    ) -> std::io::Result<()> {
        self::write_obj(self, writer, object_name)
    }

    #[doc = " Import a Mesh from OBJ file data"]
    #[doc = ""]
    #[doc = " # Arguments"]
    #[doc = " * `reader` - Source of OBJ data"]
    #[doc = " * `metadata` - Optional metadata to attach to all polygons"]
    pub fn from_obj<R: BufRead>(reader: R, metadata: Option<S>) -> std::io::Result<Mesh<S>> {
        let mut vertices = Vec::new();
        let mut normals = Vec::new();
        let mut polygons = Vec::new();

        for line_result in reader.lines() {
            let line = line_result?;
            let line = line.trim();
            if line.is_empty() || line.starts_with('#') {
                continue;
            }
            let parts: Vec<&str> = line.split_whitespace().collect();
            if parts.is_empty() {
                continue;
            }
            match parts[0] {
                "v" => {
                    if parts.len() >= 4 {
                        let x: Real = parts[1].parse().map_err(|e| {
                            std::io::Error::new(
                                std::io::ErrorKind::InvalidData,
                                format!("Invalid vertex x coordinate: {e}"),
                            )
                        })?;
                        let y: Real = parts[2].parse().map_err(|e| {
                            std::io::Error::new(
                                std::io::ErrorKind::InvalidData,
                                format!("Invalid vertex y coordinate: {e}"),
                            )
                        })?;
                        let z: Real = parts[3].parse().map_err(|e| {
                            std::io::Error::new(
                                std::io::ErrorKind::InvalidData,
                                format!("Invalid vertex z coordinate: {e}"),
                            )
                        })?;
                        vertices.push(Point3::new(x, y, z));
                    }
                }
                "vn" => {
                    if parts.len() >= 4 {
                        let x: Real = parts[1].parse().map_err(|e| {
                            std::io::Error::new(
                                std::io::ErrorKind::InvalidData,
                                format!("Invalid normal x coordinate: {e}"),
                            )
                        })?;
                        let y: Real = parts[2].parse().map_err(|e| {
                            std::io::Error::new(
                                std::io::ErrorKind::InvalidData,
                                format!("Invalid normal y coordinate: {e}"),
                            )
                        })?;
                        let z: Real = parts[3].parse().map_err(|e| {
                            std::io::Error::new(
                                std::io::ErrorKind::InvalidData,
                                format!("Invalid normal z coordinate: {e}"),
                            )
                        })?;
                        normals.push(Vector3::new(x, y, z));
                    }
                }
                "f" => {
                    if parts.len() >= 4 {
                        let face_vertices =
                            Self::parse_obj_face(&parts[1..], &vertices, &normals)?;
                        if face_vertices.len() >= 3 {
                            for i in 1..face_vertices.len() - 1 {
                                let triangle = vec![
                                    face_vertices[0],
                                    face_vertices[i],
                                    face_vertices[i + 1],
                                ];
                                polygons.push(Polygon::new(triangle, metadata.clone()));
                            }
                        }
                    }
                }
                _ => {}
            }
        }

        Ok(Mesh::from_polygons(&polygons, metadata))
    }

    fn parse_obj_face(
        face_parts: &[&str],
        vertices: &[Point3<Real>],
        normals: &[Vector3<Real>],
    ) -> std::io::Result<Vec<Vertex>> {
        let mut face_vertices = Vec::new();
        for part in face_parts {
            let indices: Vec<&str> = part.split('/').collect();
            let vertex_idx: usize = indices[0]
                .parse::<usize>()
                .map_err(|e| {
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!("Invalid vertex index: {e}"),
                    )
                })?
                - 1;
            if vertex_idx >= vertices.len() {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!("Vertex index {} out of range", vertex_idx + 1),
                ));
            }
            let position = vertices[vertex_idx];
            let normal = if indices.len() >= 3 && !indices[2].is_empty() {
                let normal_idx: usize = indices[2]
                    .parse::<usize>()
                    .map_err(|e| {
                        std::io::Error::new(
                            std::io::ErrorKind::InvalidData,
                            format!("Invalid normal index: {e}"),
                        )
                    })?
                    - 1;
                if normal_idx >= normals.len() {
                    return Err(std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!("Normal index {} out of range", normal_idx + 1),
                    ));
                }
                normals[normal_idx]
            } else {
                Vector3::new(0.0, 0.0, 1.0)
            };
            face_vertices.push(Vertex::new(position, normal));
        }
        Ok(face_vertices)
    }
}

impl<S: Clone + Debug + Send + Sync> Sketch<S> {
    #[doc = " Export this Sketch to OBJ format as a string"]
    pub fn to_obj(&self, object_name: &str) -> String {
        self::to_obj(self, object_name)
    }

    #[doc = " Export this Sketch to an OBJ file"]
    pub fn write_obj<W: Write>(
        &self,
        writer: &mut W,
        object_name: &str,
    ) -> std::io::Result<()> {
        self::write_obj(self, writer, object_name)
    }
}

impl<S: Clone + Debug + Send + Sync> crate::bmesh::BMesh<S> {
    #[doc = " Export this BMesh to OBJ format as a string"]
    pub fn to_obj(&self, object_name: &str) -> String {
        self::to_obj(self, object_name)
    }

    #[doc = " Export this BMesh to an OBJ file"]
    pub fn write_obj<W: Write>(
        &self,
        writer: &mut W,
        object_name: &str,
    ) -> std::io::Result<()> {
        self::write_obj(self, writer, object_name)
    }
}
