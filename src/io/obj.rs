//! OBJ file format support for Mesh objects
//!
//! This module provides import and export functionality for Wavefront OBJ files,
//! a widely-supported 3D file format used by many modeling and rendering applications.
use crate::float_types::Real;
use crate::mesh::Mesh;
use crate::mesh::polygon::Polygon;
use crate::mesh::vertex::Vertex;
use crate::sketch::Sketch;
use geo::CoordsIter;
use nalgebra::{Point3, Vector3};

use std::fmt::Debug;
use std::io::{BufRead, Write};

impl<S: Clone + Debug + Send + Sync> Mesh<S> {
    /// Export this Mesh to OBJ format as a string
    ///
    /// Creates a Wavefront OBJ file containing:
    /// 1. All 3D polygons from `self.polygons` (tessellated to triangles)
    /// 2. Any 2D geometry from `self.geometry` (extruded/projected to 3D)
    ///
    /// # Arguments
    /// * `object_name` - Name for the object in the OBJ file
    ///
    /// # Example
    /// ```
    /// use csgrs::mesh::Mesh;
    /// let csg: Mesh<()> = Mesh::cube(10.0, None);
    /// let obj_content = csg.to_obj("my_cube");
    /// println!("{}", obj_content);
    /// ```
    pub fn to_obj(&self, object_name: &str) -> String {
        let mut obj_content = String::new();

        // OBJ header
        obj_content.push_str("# Generated by csgrs library\n");
        obj_content.push_str(&format!("# Object: {object_name}\n"));
        obj_content.push_str("# https://github.com/timschmidt/csgrs\n\n");

        obj_content.push_str(&format!("o {object_name}\n\n"));

        let mut vertices = Vec::new();
        let mut normals = Vec::new();
        let mut faces = Vec::new();

        // Process 3D polygons
        self.polygons.iter().for_each(|poly| {
            // Tessellate polygon to triangles
            let triangles = poly.triangulate();
            let normal = poly.plane.normal().normalize();

            triangles.into_iter().for_each(|triangle| {
                let mut face_indices = Vec::new();
                let normal_idx = add_unique_normal(&mut normals, normal);

                triangle.into_iter().for_each(|vertex| {
                    let vertex_idx = add_unique_vertex(&mut vertices, vertex.pos);
                    face_indices.push((vertex_idx, normal_idx));
                });

                if face_indices.len() == 3 {
                    faces.push(face_indices);
                }
            });
        });

        // Write vertices
        vertices.iter().for_each(|vertex| {
            obj_content.push_str(&format!(
                "v {:.6} {:.6} {:.6}\n",
                vertex.x, vertex.y, vertex.z
            ));
        });

        obj_content.push('\n');

        // Write normals
        normals.iter().for_each(|normal| {
            obj_content.push_str(&format!(
                "vn {:.6} {:.6} {:.6}\n",
                normal.x, normal.y, normal.z
            ));
        });

        obj_content.push('\n');

        // Write faces (1-indexed in OBJ format)
        faces.iter().for_each(|face| {
            #[allow(clippy::single_char_add_str)]
            obj_content.push_str("f");
            face.iter().for_each(|(vertex_idx, normal_idx)| {
                obj_content.push_str(&format!(" {}//{}", vertex_idx + 1, normal_idx + 1));
            });
            obj_content.push('\n');
        });

        obj_content
    }

    /// Export this Mesh to an OBJ file
    ///
    /// # Arguments
    /// * `writer` - Where to write the OBJ data
    /// * `object_name` - Name for the object in the OBJ file
    ///
    /// # Example
    /// ```
    /// use csgrs::mesh::Mesh;
    /// use std::fs::{create_dir_all, File};
    /// # fn main() -> Result<(), Box<dyn std::error::Error>> {
    /// let csg: Mesh<()> = Mesh::cube(10.0, None);
    /// create_dir_all("target/test-output")?;
    /// let mut file = File::create("target/test-output/output.obj")?;
    /// csg.write_obj(&mut file, "my_cube")?;
    /// # Ok(())
    /// # }
    /// ```
    pub fn write_obj<W: Write>(
        &self,
        writer: &mut W,
        object_name: &str,
    ) -> std::io::Result<()> {
        let obj_content = self.to_obj(object_name);
        writer.write_all(obj_content.as_bytes())
    }

    /// Import a Mesh from OBJ file data
    ///
    /// # Arguments
    /// * `reader` - Source of OBJ data
    /// * `metadata` - Optional metadata to attach to all polygons
    ///
    /// # Example
    /// ```no_run
    /// use csgrs::mesh::Mesh;
    /// use std::fs::File;
    /// use std::io::BufReader;
    /// # fn main() -> Result<(), Box<dyn std::error::Error>> {
    /// let file = File::open("input.obj")?;
    /// let reader = BufReader::new(file);
    /// let csg: Mesh<()> = Mesh::from_obj(reader, None)?;
    /// # Ok(())
    /// # }
    /// ```
    pub fn from_obj<R: BufRead>(reader: R, metadata: Option<S>) -> std::io::Result<Mesh<S>> {
        let mut vertices = Vec::new();
        let mut normals = Vec::new();
        let mut polygons = Vec::new();

        reader.lines().try_for_each(|line_result| -> std::io::Result<()> {
            let line = line_result?;
            let line = line.trim();

            // Skip comments and empty lines
            if line.is_empty() || line.starts_with('#') {
                return Ok(());
            }

            let parts: Vec<&str> = line.split_whitespace().collect();
            if parts.is_empty() {
                return Ok(());
            }

            match parts[0] {
                "v" => {
                    // Vertex: v x y z
                    if parts.len() >= 4 {
                        let x: Real = parts[1].parse().map_err(|e| {
                            std::io::Error::new(
                                std::io::ErrorKind::InvalidData,
                                format!("Invalid vertex x coordinate: {e}"),
                            )
                        })?;
                        let y: Real = parts[2].parse().map_err(|e| {
                            std::io::Error::new(
                                std::io::ErrorKind::InvalidData,
                                format!("Invalid vertex y coordinate: {e}"),
                            )
                        })?;
                        let z: Real = parts[3].parse().map_err(|e| {
                            std::io::Error::new(
                                std::io::ErrorKind::InvalidData,
                                format!("Invalid vertex z coordinate: {e}"),
                            )
                        })?;
                        vertices.push(Point3::new(x, y, z));
                    }
                },
                "vn" => {
                    // Normal: vn x y z
                    if parts.len() >= 4 {
                        let x: Real = parts[1].parse().map_err(|e| {
                            std::io::Error::new(
                                std::io::ErrorKind::InvalidData,
                                format!("Invalid normal x coordinate: {e}"),
                            )
                        })?;
                        let y: Real = parts[2].parse().map_err(|e| {
                            std::io::Error::new(
                                std::io::ErrorKind::InvalidData,
                                format!("Invalid normal y coordinate: {e}"),
                            )
                        })?;
                        let z: Real = parts[3].parse().map_err(|e| {
                            std::io::Error::new(
                                std::io::ErrorKind::InvalidData,
                                format!("Invalid normal z coordinate: {e}"),
                            )
                        })?;
                        normals.push(Vector3::new(x, y, z));
                    }
                },
                "f" => {
                    // Face: f v1//n1 v2//n2 v3//n3 or f v1/vt1/n1 v2/vt2/n2 v3/vt3/n3
                    if parts.len() >= 4 {
                        let face_vertices =
                            Self::parse_obj_face(&parts[1..], &vertices, &normals)?;
                        if face_vertices.len() >= 3 {
                            // Convert to triangles if more than 3 vertices
                            (1..face_vertices.len() - 1).for_each(|i| {
                                let triangle = vec![
                                    face_vertices[0].clone(),
                                    face_vertices[i].clone(),
                                    face_vertices[i + 1].clone(),
                                ];
                                polygons.push(Polygon::new(triangle, metadata.clone()));
                            });
                        }
                    }
                },
                _ => {
                    // Ignore other OBJ elements (materials, groups, etc.)
                },
            }
            Ok(())
        })?;

        Ok(Mesh::from_polygons(&polygons, metadata))
    }

    // Helper function to parse OBJ face definitions
    fn parse_obj_face(
        face_parts: &[&str],
        vertices: &[Point3<Real>],
        normals: &[Vector3<Real>],
    ) -> std::io::Result<Vec<Vertex>> {
        let mut face_vertices = Vec::new();

        face_parts.iter().try_for_each(|part| -> std::io::Result<()> {
            // Parse face element: vertex_idx[/texture_idx][/normal_idx]
            let indices: Vec<&str> = part.split('/').collect();

            // Get vertex index (1-based in OBJ, convert to 0-based)
            let vertex_idx: usize = indices[0].parse::<usize>().map_err(|e| {
                std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!("Invalid vertex index: {e}"),
                )
            })? - 1;

            if vertex_idx >= vertices.len() {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!("Vertex index {} out of range", vertex_idx + 1),
                ));
            }

            let position = vertices[vertex_idx];

            // Get normal (if available)
            let normal = if indices.len() >= 3 && !indices[2].is_empty() {
                let normal_idx: usize = indices[2].parse::<usize>().map_err(|e| {
                    std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!("Invalid normal index: {e}"),
                    )
                })? - 1;

                if normal_idx >= normals.len() {
                    return Err(std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        format!("Normal index {} out of range", normal_idx + 1),
                    ));
                }

                normals[normal_idx]
            } else {
                // Calculate normal from face if not provided
                Vector3::new(0.0, 0.0, 1.0) // Default up vector
            };

            face_vertices.push(Vertex::new(position, normal));
            Ok(())
        })?;

        Ok(face_vertices)
    }
}

impl<S: Clone + Debug + Send + Sync> Sketch<S> {
    /// Export this Mesh to OBJ format as a string
    ///
    /// Creates a Wavefront OBJ file containing:
    /// 1. All 3D polygons from `self.polygons` (tessellated to triangles)
    /// 2. Any 2D geometry from `self.geometry` (extruded/projected to 3D)
    ///
    /// # Arguments
    /// * `object_name` - Name for the object in the OBJ file
    ///
    /// # Example
    /// ```
    /// use csgrs::mesh::Mesh;
    /// let csg: Mesh<()> = Mesh::cube(10.0, None);
    /// let obj_content = csg.to_obj("my_cube");
    /// println!("{}", obj_content);
    /// ```
    pub fn to_obj(&self, object_name: &str) -> String {
        let mut obj_content = String::new();

        // OBJ header
        obj_content.push_str("# Generated by csgrs library\n");
        obj_content.push_str(&format!("# Object: {object_name}\n"));
        obj_content.push_str("# https://github.com/timschmidt/csgrs\n\n");

        obj_content.push_str(&format!("o {object_name}\n\n"));

        let mut vertices = Vec::new();
        let mut normals = Vec::new();
        let mut faces = Vec::new();

        // Process 2D geometry (project to XY plane at Z=0)
        self.geometry.0.iter().for_each(|geom| {
            match geom {
                geo::Geometry::Polygon(poly2d) => {
                    self.add_2d_polygon_to_obj(
                        poly2d,
                        &mut vertices,
                        &mut normals,
                        &mut faces,
                    );
                },
                geo::Geometry::MultiPolygon(mp) => {
                    mp.0.iter().for_each(|poly2d| {
                        self.add_2d_polygon_to_obj(
                            poly2d,
                            &mut vertices,
                            &mut normals,
                            &mut faces,
                        );
                    });
                },
                _ => {}, // Skip other geometry types
            }
        });

        // Write vertices
        vertices.iter().for_each(|vertex| {
            obj_content.push_str(&format!(
                "v {:.6} {:.6} {:.6}\n",
                vertex.x, vertex.y, vertex.z
            ));
        });

        obj_content.push('\n');

        // Write normals
        normals.iter().for_each(|normal| {
            obj_content.push_str(&format!(
                "vn {:.6} {:.6} {:.6}\n",
                normal.x, normal.y, normal.z
            ));
        });

        obj_content.push('\n');

        // Write faces (1-indexed in OBJ format)
        faces.iter().for_each(|face| {
            #[allow(clippy::single_char_add_str)]
            obj_content.push_str("f");
            face.iter().for_each(|(vertex_idx, normal_idx)| {
                obj_content.push_str(&format!(" {}//{}", vertex_idx + 1, normal_idx + 1));
            });
            obj_content.push('\n');
        });

        obj_content
    }

    // Helper function to add 2D polygon to OBJ data
    fn add_2d_polygon_to_obj(
        &self,
        poly2d: &geo::Polygon<Real>,
        vertices: &mut Vec<Point3<Real>>,
        normals: &mut Vec<Vector3<Real>>,
        faces: &mut Vec<Vec<(usize, usize)>>,
    ) {
        // Get the exterior ring
        let exterior: Vec<[Real; 2]> =
            poly2d.exterior().coords_iter().map(|c| [c.x, c.y]).collect();

        // Get holes
        let holes_vec: Vec<Vec<[Real; 2]>> = poly2d
            .interiors()
            .iter()
            .map(|ring| ring.coords_iter().map(|c| [c.x, c.y]).collect())
            .collect();

        let hole_refs: Vec<&[[Real; 2]]> = holes_vec.iter().map(|h| &h[..]).collect();

        // Tessellate the 2D polygon
        let triangles_2d = Self::triangulate_2d(&exterior, &hole_refs);

        // Add triangles with normal pointing up (positive Z)
        let normal = Vector3::new(0.0, 0.0, 1.0);
        let normal_idx = add_unique_normal(normals, normal);

        triangles_2d.into_iter().for_each(|triangle| {
            let mut face_indices = Vec::new();

            triangle.into_iter().for_each(|point| {
                let vertex_3d = Point3::new(point.x, point.y, point.z);
                let vertex_idx = add_unique_vertex(vertices, vertex_3d);
                face_indices.push((vertex_idx, normal_idx));
            });

            if face_indices.len() == 3 {
                faces.push(face_indices);
            }
        });
    }
}

// Helper function to add unique vertex and return its index
fn add_unique_vertex(vertices: &mut Vec<Point3<Real>>, vertex: Point3<Real>) -> usize {
    const EPSILON: Real = 1e-6;

    // Check if vertex already exists (within tolerance)
    if let Some((i, _)) = vertices.iter().enumerate().find(|(_, existing)| {
        (existing.coords - vertex.coords).norm() < EPSILON
    }) {
        return i;
    }

    // Add new vertex
    vertices.push(vertex);
    vertices.len() - 1
}

// Helper function to add unique normal and return its index
fn add_unique_normal(normals: &mut Vec<Vector3<Real>>, normal: Vector3<Real>) -> usize {
    const EPSILON: Real = 1e-6;

    // Check if normal already exists (within tolerance)
    if let Some((i, _)) = normals.iter().enumerate().find(|(_, existing)| {
        (*existing - normal).norm() < EPSILON
    }) {
        return i;
    }

    // Add new normal
    normals.push(normal);
    normals.len() - 1
}
